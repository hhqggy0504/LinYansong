# wsl Ubuntu20.04安装

https://zhuanlan.zhihu.com/p/466001838

本机电脑安装在C之后就找不到了，就继续使用

# Linux Command Line

shell 就是一个程序，它接受从键盘输入的命令， 然后把命令传递给操作系统去执行。几乎所有的 Linux 发行版都提供一个名为 bash 的 来自 GNU 项目的 shell 程序。“bash” 是 “Bourne Again SHell” 的首字母缩写， 所指的是这样一个事实，bash 是最初 Unix 上由 Steve Bourne 写成 shell 程序 sh 的增强版。

    ls -a ------显示隐藏文件
    ls -l ------结果以长模式输出

**选项和参数**
大多数命令是如何工作的。命令名经常会带有一个或多个用来更正命令行为的选项， 更进一步，选项后面会带有一个或多个参数，这些参数是命令作用的对象。所以大多数命令看起来像这样：

    command -options arguments

            
    ls -lt   ----- “l” 选项产生长格式输出，“t”选项按文件修改时间的先后来排序。
    ls -lt --reverse   ------    结果会以相反的顺序输出



    cp — 复制文件和目录
    mv — 移动/重命名文件和目录
    mkdir — 创建目录
    rm — 删除文件和目录
    ln — 创建硬链接和符号链接

    通配符           >>>>>>>>         意义
    *               >>>>>>>>>>>>>    匹配任意多个字符（包括零个或一个）
    ?	            >>>>>>>>>>>>>    匹配任意一个字符（不包括零个）
    [characters]	>>>>>>>>         匹配任意一个属于字符集中的字符
    [!characters]	>>>>>>>>         匹配任意一个不是字符集中的字符
    [[:class:]]		>>>>>>>>         匹配任意一个属于指定字符类中的字符


    字符类	      >>>>>>>>      意义
    [:alnum:]	  >>>>>>>>      匹配任意一个字母或数字
    [:alpha:]	  >>>>>>>>      匹配任意一个字母
    [:digit:]	  >>>>>>>>      匹配任意一个数字
    [:lower:]	  >>>>>>>>      匹配任意一个小写字母
    [:upper]	  >>>>>>>>      匹配任意一个大写字母

    _模式	                >>>>>>>>      匹配对象
    *	                    >>>>>>>>      所有文件
    g*	                    >>>>>>>>      文件名以“g”开头的文件
    b*.txt	                >>>>>>>>      以"b"开头，中间有零个或任意多个字符，并以".txt"结尾的文件
    Data???	                >>>>>>>>      以“Data”开头，其后紧接着3个字符的文件
    [abc]*	                >>>>>>>>      文件名以"a","b",或"c"开头的文件
    BACKUP.[0-9][0-9][0-9]	>>>>>>>>      以"BACKUP."开头，并紧接着3个数字的文件
    [[:upper:]]*	        >>>>>>>>      以大写字母开头的文件
    [![:digit:]]*	        >>>>>>>>      不以数字开头的文件
    *[[:lower:]123]	        >>>>>>>>      文件名以小写字母结尾，或以 “1”，“2”，或 “3” 结尾的文件_



**mkdir 命令**是用来创建目录的。它这样工作：

    mkdir directory...
注意表示法: 在描述一个命令时（如上所示），当有三个圆点跟在一个命令的参数后面， 这意味着那个参数可以重复，就像这样：

    mkdir dir1
会创建一个名为”dir1”的目录，而

    mkdir dir1 dir2 dir3
会创建三个目录，名为 dir1, dir2, dir3。


小心 rm!

类 Unix 的操作系统，比如说 Linux，没有复原命令。一旦你用 rm 删除了一些东西， 它就消失了。Linux 假定你很聪明，你知道你在做什么。

尤其要小心通配符。思考一下这个经典的例子。假如说，你只想删除一个目录中的 HTML 文件。输入：

rm *.html

这是正确的，如果你不小心在 “*” 和 “.html” 之间多输入了一个空格，就像这样：

rm * .html

这个 rm 命令会删除目录中的所有文件，还会抱怨没有文件叫做 “.html”。

小贴士。 无论什么时候，rm 命令用到通配符（除了仔细检查输入的内容外！）， 用 ls 命令来测试通配符。这会让你看到要删除的文件列表。然后按下上箭头按键，重新调用 刚刚执行的命令，用 rm 替换 ls。

cp - 复制文件和目录
cp 命令，复制文件或者目录。它有两种使用方法：

cp item1 item2
复制单个文件或目录”item1”到文件或目录”item2”，和：

cp item... directory
复制多个项目（文件或目录）到一个目录下。


-----------------

重定向标准输出
I/O 重定向允许我们来重定义标准输出送到哪里。重定向标准输出到另一个文件除了屏幕，我们使用 “>” 重定向符，其后跟着文件名。为什么我们要这样做呢？因为有时候把一个命令的运行结果存储到 一个文件很有用处。例如，我们可以告诉 shell 把 ls 命令的运行结果输送到文件 ls-output.txt 中去， 由文件代替屏幕。

    [me@linuxbox ~]$ ls -l /usr/bin > ls-output.txt

    [me@linuxbox ~]$ ls -l /bin/usr 2> ls-error.txt
文件描述符”2”，紧挨着放在重定向操作符之前，来执行重定向标准错误到文件 ls-error.txt 任务。

    [me@linuxbox ~]$ ls -l /bin/usr > ls-output.txt 2>&1
使用这种方法，我们完成两个重定向。首先重定向标准输出到文件 ls-output.txt，然后 重定向文件描述符2（标准错误）到文件描述符1（标准输出）使用表示法2>&1。
